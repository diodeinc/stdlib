"""Generic Component Matcher

Automatically assigns house MPNs to resistors and capacitors.
"""

load("../units.zen", "Voltage", "VoltageRange", "Resistance", "ResistanceRange", "Capacitance", "Power")
load(
    "helpers.zen",
    "prop",
    "set_primary_and_alts",
    "find_e_series_match",
    "iec60062_3digit",
    "iec60062_4digit",
    "encode_3digit_multiplier",
    "panasonic_erj",
    "uniroyal",
    "discrete_resistor_series",
    "murata_cap",
    "led",
)


# Dielectric quality ranking: C0G/NP0 > X7T > X7R > X7S > X5R > Y5V > Z5U
_DIELECTRIC_RANK = {
    "C0G": 0,
    "NP0": 0,
    "X7T": 1,
    "X7R": 2,
    "X7S": 3,
    "X5R": 4,
    "Y5V": 5,
    "Z5U": 6,
}

# Resistor series by package
SERIES_BY_PKG = {
    "0201": [
        # 0 ohm jumpers (checked first for exact 0 ohm match)
        discrete_resistor_series(
            "Panasonic Electronic Components",
            "ERJ-1GJ",
            "25V",
            "0.05W",
            "0%",
            [("0Ohm", "ERJ-1GJ0R00C")],
        ),
        discrete_resistor_series(
            "YAGEO",
            "RC_L",
            "25V",
            "0.05W",
            "0%",
            [("0Ohm", "RC0201FR-070RL")],
        ),
    ],
    "0402": [
        # 0 ohm jumpers (checked first for exact 0 ohm match)
        discrete_resistor_series(
            "Panasonic Electronic Components",
            "ERJ-2G",
            "50V",
            "0.1W",
            "0%",
            [("0Ohm", "ERJ-2GE0R00X")],
        ),
        panasonic_erj("ERJ-H2CF", "1Ohm – 10Ohm", "50V", "0.1W", "1%", ["e96", "e24"], "X", iec60062_4digit),
        panasonic_erj("ERJ-2RKF", "10Ohm – 1MOhm", "50V", "0.1W", "1%", ["e96", "e24"], "X", iec60062_4digit),
        panasonic_erj("ERJ-U02J", "1MOhm – 10MOhm", "50V", "0.1W", "5%", ["e24"], "X", iec60062_3digit),
        panasonic_erj("ERJ-PA2F", "1Ohm – 1MOhm", "50V", "0.1W", "1%", ["e96", "e24"], "X", iec60062_4digit),
        # Uniroyal 0402WGF series
        uniroyal("0402WGF", "10Ohm – 10MOhm", "50V", "0.0625W", "1%", ["e96", "e24"], "TCE", encode_3digit_multiplier),
    ],
    "0603": [
        # 0 ohm jumpers (checked first for exact 0 ohm match)
        discrete_resistor_series(
            "Panasonic Electronic Components",
            "ERJ-3G",
            "75V",
            "0.333W",
            "0%",
            [("0Ohm", "ERJ-3GEY0R00V")],
        ),
        panasonic_erj("ERJ-H3QF", "1Ohm – 10Ohm", "75V", "0.333W", "1%", ["e96", "e24"], "V", iec60062_4digit),
        panasonic_erj("ERJ-3EKF", "10Ohm – 1MOhm", "75V", "0.333W", "1%", ["e96", "e24"], "V", iec60062_4digit),
        panasonic_erj("ERJ-U03J", "1MOhm – 10MOhm", "75V", "0.333W", "5%", ["e24"], "V", iec60062_3digit),
        panasonic_erj("ERJ-PA3F", "1Ohm – 1MOhm", "75V", "0.333W", "1%", ["e96", "e24"], "V", iec60062_4digit),
    ],
    "2512": [
        # Stackpole CSNL series: Current sense resistors
        discrete_resistor_series(
            "Stackpole Electronics Inc",
            "CSNL2512",
            "170V",
            "2W",
            "1%",
            [
                ("1mOhm", "CSNL2512FT1L00"),
                ("2mOhm", "CSNL2512FT2L00"),
                ("3mOhm", "CSNL2512FT3L00"),
                ("4mOhm", "CSNL2512FT4L00"),
                ("5mOhm", "CSNL2512FT5L00"),
                ("10mOhm", "CSNL2512FT10L0"),
            ],
        ),
        # YAGEO PA_E series: AEC-Q200 current sense resistors
        discrete_resistor_series(
            "YAGEO",
            "PA_E",
            "170V",
            "2W",
            "1%",
            [
                ("1mOhm", "PA2512FKF7W0R001E"),
                ("2mOhm", "PA2512FKF7W0R002E"),
                ("3mOhm", "PA2512FKF7W0R003E"),
                ("4mOhm", "PA2512FKF7W0R004E"),
                ("5mOhm", "PA2512FKF7W0R005E"),
                ("10mOhm", "PA2512FKF7W0R01E"),
            ],
        ),
    ],
}

# House capacitor catalog (Murata parts) by package
HOUSE_CAPS_BY_PKG = {
    "0201": [
        murata_cap("X7R", "10V", "10nF 10%", "GCM033R71A103KA03", ["D", "J"]),
        murata_cap("X7R", "10V", "100nF 10%", "GRM033Z71A104KE14", ["D", "J"]),
    ],
    "0402": [
        murata_cap("C0G", "50V", "10pF 1%", "GCM1555C1H100FA16", ["D", "J"]),
        murata_cap("C0G", "50V", "12pF 1%", "GCM1555C1H120FA16", ["D", "J"]),
        murata_cap("C0G", "50V", "22pF 1%", "GCM1555C1H220FA16", ["D", "J"]),
        murata_cap("C0G", "50V", "30pF 1%", "GCM1555C1H300FA16", ["D", "J"]),
        murata_cap("C0G", "50V", "47pF 1%", "GCM1555C1H470FA16", ["D", "J"]),
        murata_cap("C0G", "50V", "82pF 1%", "GCM1555C1H820FA16", ["D", "J"]),
        murata_cap("C0G", "50V", "100pF 1%", "GCM1555C1H101FA16", ["D", "J"]),
        murata_cap("C0G", "50V", "220pF 1%", "GCM1555C1H221FA16", ["D", "J"]),
        murata_cap("C0G", "50V", "330pF 1%", "GCM1555C1H331FA16", ["D", "J"]),
        murata_cap("C0G", "50V", "430pF 1%", "GCM1555C1H431FA16", ["D", "J"]),
        murata_cap("C0G", "50V", "1nF 1%", "GCM1555C1H102FA16", ["D", "J"]),
        murata_cap("C0G", "35V", "10nF 2%", "GRM1555CYA103GE01", ["D", "J"]),
        murata_cap("X7R", "50V", "10nF 10%", "GCM155R71H103KA55", ["D", "J"]),
        murata_cap("X7R", "50V", "22nF 10%", "GCM155R71H223KA55", ["D", "J"]),
        murata_cap("X7R", "50V", "100nF 10%", "GCM155R71H104KE02", ["D", "J"]),
        murata_cap("X7R", "10V", "1uF 10%", "GRM155Z71A105KE01", ["D", "J"]),
    ],
    "0603": [
        murata_cap("C0G", "100V", "10nF 5%", "GCM1885C2A103JE02", ["D", "J", "W", "V"]),
        murata_cap("X7R", "100V", "22nF 10%", "GCM188R72A223KA37", ["D", "J"]),
        murata_cap("X7R", "100V", "100nF 10%", "GRM188R72A104KA35", ["D", "J"]),
        murata_cap("X7R", "50V", "220nF 10%", "GCM188R71H224KA64", ["D", "J"]),
        murata_cap("X7R", "25V", "1uF 10%", "GCM188R71E105KA64", ["D", "J"]),
        murata_cap("X7R", "25V", "2.2uF 20%", "GRM188Z71E225ME43", ["D", "J"]),
        murata_cap("X7R", "16V", "4.7uF 10%", "GRM188Z71C475KE21", ["D", "J"]),
        murata_cap("X7R", "10V", "10uF 10%", "GRM188Z71A106KA73", ["D", "J"]),
    ],
    "0805": [
        murata_cap("X7R", "100V", "220nF 10%", "GRM21AR72A224KAC5", ["K", "L"]),
        murata_cap("X7R", "50V", "4.7uF 10%", "GRM21BZ71H475KE15", ["K", "L"]),
        murata_cap("X7R", "25V", "10uF 10%", "GRM21BZ71E106KE15", ["K", "L"]),
        murata_cap("X7R", "10V", "22uF 20%", "GRM21BZ71A226ME15", ["K", "L"]),
    ],
    "1206": [
        murata_cap("X7R", "100V", "4.7uF 10%", "GRM31CZ72A475KE11", ["K", "L"]),
        # X5R, but GRT has good DC bias characteristics
        murata_cap("X5R", "50V", "10uF 10%", "GRT31CR61H106KE01", ["K", "L"]),
        murata_cap("X7R", "16V", "22uF 20%", "GRM31CZ71C226ME15", ["K", "L"]),
    ],
    "1210": [
        murata_cap("X7R", "25V", "22uF 10%", "GRM32ER71E226KE15", ["K", "L"]),
        murata_cap("X7R", "10V", "47uF 10%", "GRM32ER71A476KE15", ["K", "L"]),
    ],
}

# House LED catalog by package
HOUSE_LEDS_BY_PKG = {
    "0402": [
        # Vishay CHIPLED series (@ 5mA for blue, @ 20mA for AlInGaP)
        led("blue", "2.65V – 3.15V (2.8V nom.)", "VLMB1500-GS08", "Vishay Semiconductor Opto Division"),
        led("green", "1.9V – 2.4V (2V nom.)", "VLMG1500-GS08", "Vishay Semiconductor Opto Division"),
        led("orange", "1.8V – 2.4V (2V nom.)", "VLMO1500-GS08", "Vishay Semiconductor Opto Division"),
        led("red", "1.8V – 2.4V (2V nom.)", "VLMS1500-GS08", "Vishay Semiconductor Opto Division"),
        # Lite-On LTST-C281 series (0.35mm height, AlInGaP K-series @ 5mA)
        led("orange", "1.7V – 2.3V (2V nom.)", "LTST-C281KFKT-5A", "Lite-On Inc."),
        led("green", "1.7V – 2.3V (2V nom.)", "LTST-C281KGKT-5A", "Lite-On Inc."),
        led("red", "1.7V – 2.3V (2V nom.)", "LTST-C281KRKT-5A", "Lite-On Inc."),
        led("yellow", "1.7V – 2.3V (2V nom.)", "LTST-C281KSKT-5A", "Lite-On Inc."),
        # Lite-On LTST-C281 series (0.35mm height, InGaN T-series blue @ 5mA)
        led("blue", "2.65V – 3.15V (2.9V nom.)", "LTST-C281TBKT-5A", "Lite-On Inc."),
        # Lite-On LTST-C283 series (0.2mm height, AlInGaP K-series @ 5mA)
        led("green", "1.7V – 2.3V (2V nom.)", "LTST-C283KGKT-5A", "Lite-On Inc."),
        led("red", "1.7V – 2.3V (2V nom.)", "LTST-C283KRKT-5A", "Lite-On Inc."),
        # Lite-On LTST-C283 series (0.2mm height, InGaN T-series blue @ 5mA)
        led("blue", "2.65V – 3.15V (2.9V nom.)", "LTST-C283TBKT-5A", "Lite-On Inc."),
    ],
}


def assign_house_resistor(c, series_by_pkg):
    """Assign house resistor MPNs."""
    resistance = Resistance(prop(c, ["resistance", "Resistance"]))
    pkg = prop(c, ["package", "Package"])
    v_req = prop(c, ["Voltage", "voltage"])
    voltage_constraint = Voltage(v_req) if v_req else None
    p_req = prop(c, ["Power", "power"])
    power_constraint = Power(p_req) if p_req else None

    series_list = series_by_pkg.get(pkg, [])
    matches = []
    manufacturer = None

    for spec in series_list:
        spec_type = spec.get("type", "e_series")
        spec_max_v = spec["max_v"]
        spec_power = spec["power"]
        spec_tol = float(spec["tolerance"].replace("%", "")) / 100.0

        if voltage_constraint and voltage_constraint > spec_max_v:
            continue

        if power_constraint and power_constraint > spec_power:
            continue

        if spec_type == "discrete":
            # Discrete series: exact value match with tolerance
            r_with_tol = resistance.with_tolerance(spec_tol) if resistance.tolerance <= 0 else resistance

            for val_str, mpn in spec["values"]:
                val_r = Resistance(val_str).with_tolerance(spec_tol)
                if val_r.within(r_with_tol):
                    matches.append(mpn)
                    if manufacturer == None:
                        manufacturer = spec["manufacturer"]
        else:
            # E-series: standard matching logic
            spec_range = spec["resistance_range"]
            matched = find_e_series_match(resistance, spec_tol, spec["e_series"])
            if not matched or matched.value < spec_range.min or matched.value > spec_range.max:
                continue

            encoder = spec.get("encode", iec60062_4digit)
            code = encoder(matched.value)
            mpn = spec["series"] + code + spec.get("suffix", "X")
            matches.append(mpn)
            if manufacturer == None:
                manufacturer = spec["manufacturer"]

    if matches:
        set_primary_and_alts(c, matches[0], manufacturer, matches[1:])
        c.matcher = "assign_house_resistor"
        return

    # Generate warning
    warn(
        "No house resistor found for "
        + c.value
        + " "
        + pkg
        + ".\nTry using different component values or specify mpn directly "
        + "(https://docs.pcb.new/pages/spec#match-component-match%2C-parts)",
        kind="bom.match_generic",
    )


def assign_house_capacitor(c, house_caps_by_pkg):
    """Assign Murata house MPNs to capacitors."""
    cap = Capacitance(prop(c, ["capacitance", "Capacitance"]))
    pkg = prop(c, ["package", "Package"])
    req_diel = prop(c, ["dielectric", "Dielectric"])
    v_req = prop(c, ["voltage", "Voltage"])
    req_voltage = Voltage(v_req) if v_req else None

    if cap.tolerance <= 0:
        cap = cap.with_tolerance(0.2)

    parts = house_caps_by_pkg.get(pkg, [])
    matches = []

    for p in parts:
        p_cap = p["cap"]
        p_voltage = p["voltage"]

        if req_diel:
            h_rank = _DIELECTRIC_RANK.get(p["dielectric"], 99)
            r_rank = _DIELECTRIC_RANK.get(req_diel, 99)
            if h_rank > r_rank:
                continue

        if req_voltage and p_voltage < req_voltage:
            continue

        if not p_cap.within(cap):
            continue

        err = p_cap.diff(cap) / cap
        diel_rank = _DIELECTRIC_RANK.get(p["dielectric"], 99)
        score = (err, p_cap.tolerance, p_voltage * -1, diel_rank)

        matches.append((score, p))

    if matches:
        sorted_matches = sorted(matches, key=lambda x: x[0])
        all_mpns = []
        manufacturer = None

        for score, p in sorted_matches:
            if manufacturer == None:
                manufacturer = p["manufacturer"]
            all_mpns.extend(p["mpns"])

        set_primary_and_alts(c, all_mpns[0], manufacturer, all_mpns[1:])
        c.matcher = "assign_house_capacitor"
        return

    # Generate warning
    warn(
        "No house cap found for "
        + c.value
        + " "
        + pkg
        + ".\nTry using different component values or specify mpn directly "
        + "(https://docs.pcb.new/pages/spec#match-component-match%2C-parts)",
        kind="bom.match_generic",
    )


def assign_house_led(c, house_leds_by_pkg):
    """Assign house LED MPNs."""
    pkg = prop(c, ["package", "Package"])
    color = prop(c, ["color", "Color"])
    v_req = prop(c, ["forward_voltage", "Forward_voltage"])
    req_voltage = Voltage(v_req) if v_req else None

    parts = house_leds_by_pkg.get(pkg, [])
    matches = []

    for p in parts:
        # Match color exactly
        if p["color"] != color:
            continue

        if req_voltage:
            if req_voltage.tolerance == 0.0:
                # Assume 15% tolerance if not specified
                req_voltage = req_voltage.with_tolerance(0.15)
            # LED's Vf should be within the specified range
            if p["forward_voltage"] not in req_voltage:
                continue

        matches.append(p)

    if matches:
        # Use first match as primary, rest as alternatives
        manufacturer = matches[0]["manufacturer"]
        all_mpns = [p["mpn"] for p in matches]
        set_primary_and_alts(c, all_mpns[0], manufacturer, all_mpns[1:])
        c.matcher = "assign_house_led"
        return

    # Generate warning
    warn(
        "No house LED found for "
        + c.value
        + " "
        + pkg
        + ".\nTry using different component values or specify mpn directly "
        + "(https://docs.pcb.new/pages/spec#match-component-match%2C-parts)",
        kind="bom.match_generic",
    )


def assign_house_parts(c):
    """Single modifier that dispatches to resistor, capacitor, or LED matching."""
    # Skip if already has MPN
    if hasattr(c, "mpn") and c.mpn:
        return

    # Dispatch based on component type
    if c.type == "resistor":
        assign_house_resistor(c, SERIES_BY_PKG)
    elif c.type == "capacitor":
        assign_house_capacitor(c, HOUSE_CAPS_BY_PKG)
    elif c.type == "led":
        assign_house_led(c, HOUSE_LEDS_BY_PKG)
